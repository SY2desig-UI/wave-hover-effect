
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Wave Hover Video</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; background: black; overflow: hidden; }
    #imageContainer { width: 100vw; height: 100vh; }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="imageContainer">
    <img id="myImage" src="https://storage.googleapis.com/ky_design_lab/persenal%20finece.mp4" style="display: none;" />
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r121/three.min.js"></script>
  <script>
    const imageContainer = document.getElementById("imageContainer");
    const imageElement = document.getElementById("myImage");

    let scene, camera, renderer, planeMesh;
    let currentState = { mousePosition: { x: 0, y: 0 }, waveIntensity: 0.005 };
    let targetState = { mousePosition: { x: 0, y: 0 }, waveIntensity: 0.005 };

    const ANIMATION_CONFIG = {
      transitionSpeed: 0.03,
      baseIntensity: 0.005,
      hoverIntensity: 0.009
    };

    const vertexShader = \`
      varying vec2 vUv;
      void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    \`;

    const fragmentShader = \`
      uniform float u_time;
      uniform vec2 u_mouse;
      uniform float u_intensity;
      uniform sampler2D u_texture;
      varying vec2 vUv;

      void main() {
          vec2 uv = vUv;
          float wave1 = sin(uv.x * 10.0 + u_time * 0.5 + u_mouse.x * 5.0) * u_intensity;
          float wave2 = sin(uv.y * 12.0 + u_time * 0.8 + u_mouse.y * 4.0) * u_intensity;
          float wave3 = cos(uv.x * 8.0 + u_time * 0.5 + u_mouse.x * 3.0) * u_intensity;
          float wave4 = cos(uv.y * 9.0 + u_time * 0.7 + u_mouse.y * 3.5) * u_intensity;

          uv.y += wave1 + wave2;
          uv.x += wave3 + wave4;

          gl_FragColor = texture2D(u_texture, uv);
      }
    \`;

    function initializeScene(texture) {
      camera = new THREE.PerspectiveCamera(80, imageContainer.offsetWidth / imageContainer.offsetHeight, 0.01, 10);
      camera.position.z = 1;

      scene = new THREE.Scene();

      const shaderUniforms = {
        u_time: { type: "f", value: 1.0 },
        u_mouse: { type: "v2", value: new THREE.Vector2() },
        u_intensity: { type: "f", value: currentState.waveIntensity },
        u_texture: { type: "t", value: texture }
      };

      planeMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(2, 2),
        new THREE.ShaderMaterial({
          uniforms: shaderUniforms,
          vertexShader,
          fragmentShader
        })
      );

      scene.add(planeMesh);

      renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      renderer.setSize(imageContainer.offsetWidth, imageContainer.offsetHeight);
      imageContainer.appendChild(renderer.domElement);
      imageContainer.addEventListener("mousemove", handleMouseMove, false);
    }

    new THREE.TextureLoader().load(imageElement.src, (texture) => {
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      initializeScene(texture);
      animateScene();
    });

    function animateScene() {
      requestAnimationFrame(animateScene);

      currentState.mousePosition.x = updateValue(targetState.mousePosition.x, currentState.mousePosition.x, ANIMATION_CONFIG.transitionSpeed);
      currentState.mousePosition.y = updateValue(targetState.mousePosition.y, currentState.mousePosition.y, ANIMATION_CONFIG.transitionSpeed);
      currentState.waveIntensity = updateValue(targetState.waveIntensity, currentState.waveIntensity, ANIMATION_CONFIG.transitionSpeed);

      const uniforms = planeMesh.material.uniforms;
      uniforms.u_intensity.value = currentState.waveIntensity;
      uniforms.u_time.value += 0.005;
      uniforms.u_mouse.value.set(currentState.mousePosition.x, currentState.mousePosition.y);

      renderer.render(scene, camera);
    }

    function updateValue(target, current, speed) {
      return current + (target - current) * speed;
    }

    imageContainer.addEventListener("mouseover", () => {
      targetState.waveIntensity = ANIMATION_CONFIG.hoverIntensity;
    });

    imageContainer.addEventListener("mouseout", () => {
      targetState.waveIntensity = ANIMATION_CONFIG.baseIntensity;
      targetState.mousePosition = { x: 0, y: 0 };
    });

    function handleMouseMove(event) {
      const rect = imageContainer.getBoundingClientRect();
      targetState.mousePosition.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      targetState.mousePosition.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }
  </script>
</body>
</html>
